<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dispatch Analysis · JETTest.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://aviatesk.github.io/JETTest.jl/toolset/dispatch/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../generated-index/">JETTest.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../generated-index/">README</a></li><li><span class="tocitem">Toolset</span><ul><li class="is-active"><a class="tocitem" href>Dispatch Analysis</a><ul class="internal"><li><a class="tocitem" href="#dispatch-analysis-quick-start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#dispatch-analysis-entry-points"><span>Entry Points</span></a></li><li><a class="tocitem" href="#dispatch-analysis-configurations"><span>Configurations</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Toolset</a></li><li class="is-active"><a href>Dispatch Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dispatch Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/aviatesk/JETTest.jl/blob/master/docs/src/toolset/dispatch.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dispatch-Analysis"><a class="docs-heading-anchor" href="#Dispatch-Analysis">Dispatch Analysis</a><a id="Dispatch-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Dispatch-Analysis" title="Permalink"></a></h1><p>When Julia compiles your code but type inference was not so successful, the compiler is likely to be unable to resolve which method should be called at each generic function call-site, and then it will be looked up at runtime. That is called &quot;runtime dispatch&quot;, which is known as a common source of performance problem — since the compiler can&#39;t do various kinds of optimizations including inlining when it doesn&#39;t know matching methods, and method lookup itself can also be a bottleneck if the call happens many times.</p><p>In order to avoid this problem, we usually use <a href="https://docs.julialang.org/en/v1/base/base/#Base.code_typed"><code>code_typed</code></a>, inspect its output, and check if there is anywhere type is not well inferred (i.e. where is &quot;type-instable&quot;) and optimization was not successful. But the problem is that <code>code_typed</code> can only present the &quot;final&quot; output of inference or optimization, and we can&#39;t inspect an entire call graph and may not be able to find where a problem happened and how the &quot;type instability&quot; has been propagated.</p><p>There is a nice package called <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>, which allows us to inspect the output of <code>code_typed</code> by <em>descending</em> into a call tree, recursively and interactively. The workflow with Cthulhu is much more powerful, but still, it&#39;s tedious.</p><p>So, why not automate it ? JETTest.jl implements such an analyzer that analyzes optimized IRs of your code and automatically detects anywhere the compiler failed to optimize your code, or couldn&#39;t resolve matching methods and thus dispatch will happen at runtime.</p><h2 id="dispatch-analysis-quick-start"><a class="docs-heading-anchor" href="#dispatch-analysis-quick-start">Quick Start</a><a id="dispatch-analysis-quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#dispatch-analysis-quick-start" title="Permalink"></a></h2><p><a href="#JETTest.@report_dispatch"><code>@report_dispatch</code></a> analyzes the entire call graph of a given function call, and then reports optimization failures and runtime dispatch points:</p><pre><code class="language-julia-repl">julia&gt; using JETTest

julia&gt; addsincos(v1, v2) = sin(v1) + cos(v2); # main computation kernel

julia&gt; params = (; v1 = 10, v2 = -10);

julia&gt; f() = addsincos(params.v1, params.v2); # this function uses the non-constant global variable and thus is very type-unstable

julia&gt; @report_dispatch f() # runtime dispatches will be reported
═════ 6 possible errors found ═════
┌ @ none:1 Main.__atexample__named__quickstart.addsincos(Base.getproperty(Main.__atexample__named__quickstart.params, :v1), Base.getproperty(Main.__atexample__named__quickstart.params, :v2))
│┌ @ none:2 Main.__atexample__named__quickstart.sin(v1)
││ runtime dispatch detected: Main.__atexample__named__quickstart.sin(v1::Any)
│└──────────
│┌ @ none:2 Main.__atexample__named__quickstart.cos(v2)
││ runtime dispatch detected: Main.__atexample__named__quickstart.cos(v2::Any)
│└──────────
│┌ @ none:2 Main.__atexample__named__quickstart.+(%1, %2)
││ runtime dispatch detected: Main.__atexample__named__quickstart.+(%1::Any, %2::Any)
│└──────────
┌ @ none:1 Base.getproperty(%1, :v1)
│ runtime dispatch detected: Base.getproperty(%1::Any, :v1::Symbol)
└──────────
┌ @ none:1 Base.getproperty(%3, :v2)
│ runtime dispatch detected: Base.getproperty(%3::Any, :v2::Symbol)
└──────────
┌ @ none:1 Main.__atexample__named__quickstart.addsincos(%2, %4)
│ runtime dispatch detected: Main.__atexample__named__quickstart.addsincos(%2::Any, %4::Any)
└──────────
Any

julia&gt; f(params) = addsincos(params.v1, params.v2); # we can pass parameters as a function argument, and then everything is type-stable

julia&gt; @report_dispatch f((; v1 = 10, v2 = -10)) # now runtime dispatch free !
No errors !
Float64</code></pre><p>With the <a href="#dispatch-analysis-configurations"><code>frame_filter</code></a> configuration, we can focus on type instabilities within specific modules of our interest:</p><pre><code class="language-julia-repl">julia&gt; # problem: when ∑1/n exceeds 30 ?
       function compute(x)
           r = 1
           s = 0.0
           n = 1
           @time while r &lt; x
               s += 1/n
               if s ≥ r
                   # `println` call is full of runtime dispatches for good reasons
                   # and we&#39;re not interested in type-instabilities within this call
                   # since we know it&#39;s only called few times
                   println(&quot;round $r/$x has been finished&quot;)
                   r += 1
               end
               n += 1
           end
           return n, s
       end
compute (generic function with 1 method)

julia&gt; @report_dispatch compute(30) # bunch of reports will be reported from the `println` call
═════ 44 possible errors found ═════
┌ @ none:12 Main.__atexample__named__quickstart.println(Base.string(&quot;round &quot;, r, &quot;/&quot;, x, &quot; has been finished&quot;))
│┌ @ coreio.jl:4 Base.println(Core.tuple(Core.typeassert(Base.stdout, Base.IO)), xs...)
││┌ @ strings/io.jl:73 Base.print(Core.tuple(io), xs, Core.tuple(&quot;\n&quot;)...)
│││┌ @ strings/io.jl:43 Base.lock(io)
││││┌ @ show.jl:334 Base.lock(Base.getproperty(io, :io))
│││││┌ @ stream.jl:282 Base.lock(Base.getproperty(s, :lock))
││││││┌ @ lock.jl:100 Base.wait(Base.getproperty(rl, :cond_wait))
│││││││┌ @ condition.jl:112 Base.wait()
││││││││┌ @ task.jl:809 Base.try_yieldto(Base.ensure_rescheduled)
│││││││││┌ @ task.jl:747 Base.getproperty(%7, :result)
││││││││││ runtime dispatch detected: Base.getproperty(%7::Task, :result::Symbol)
│││││││││└───────────────
│││││││││┌ @ task.jl:748 Base.setproperty!(%7, :result, Base.nothing)
││││││││││ runtime dispatch detected: Base.setproperty!(%7::Task, :result::Symbol, Base.nothing)
│││││││││└───────────────
│││││││││┌ @ task.jl:749 Base.setproperty!(%7, :_isexception, false)
││││││││││ runtime dispatch detected: Base.setproperty!(%7::Task, :_isexception::Symbol, false)
│││││││││└───────────────
│││││││┌ @ condition.jl:114 Base.list_deletefirst!(%63, %57)
││││││││ runtime dispatch detected: Base.list_deletefirst!(%63::Any, %57::Task)
│││││││└────────────────────
│││││┌ @ stream.jl:282 Base.lock(%3)
││││││ runtime dispatch detected: Base.lock(%3::Base.AbstractLock)
│││││└─────────────────
││││┌ @ show.jl:334 Base.lock(%1)
│││││ runtime dispatch detected: Base.lock(%1::IO)
││││└───────────────
│││┌ @ strings/io.jl:46 Base.print(io, x)
││││┌ @ strings/io.jl:244 Base.write(io, s)
│││││┌ @ strings/io.jl:242 Base.unsafe_write(io, %2, %5)
││││││ runtime dispatch detected: Base.unsafe_write(io::IO, %2::Ptr{UInt8}, %5::UInt64)
│││││└─────────────────────
│││││┌ @ strings/io.jl:242 Base.Int(%6)
││││││ runtime dispatch detected: Base.Int(%6::Any)
│││││└─────────────────────
││││┌ @ strings/io.jl:244 Base.write(io, s)
│││││ runtime dispatch detected: Base.write(io::IO, s::String)
││││└─────────────────────
│││┌ @ strings/io.jl:49 Base.unlock(io)
││││┌ @ show.jl:335 Base.unlock(Base.getproperty(io, :io))
│││││┌ @ stream.jl:283 Base.unlock(Base.getproperty(s, :lock))
││││││┌ @ lock.jl:132 Base.notify(Base.getproperty(rl, :cond_wait))
│││││││┌ @ condition.jl:130 #self#(c, Base.nothing)
││││││││┌ @ condition.jl:130 Base.#notify#548(true, false, #self#, c, arg)
│││││││││┌ @ condition.jl:130 Base.notify(c, arg, all, error)
││││││││││┌ @ condition.jl:136 Core.kwfunc(Base.schedule)(Core.apply_type(Core.NamedTuple, (:error,))(Core.tuple(error)), Base.schedule, t, arg)
│││││││││││┌ @ task.jl:678 Base.#schedule#569(error, _3, t, arg)
││││││││││││┌ @ task.jl:680 %10(%11, t)
│││││││││││││ runtime dispatch detected: %10::typeof(Base.list_deletefirst!)(%11::Any, t::Task)
││││││││││││└───────────────
│││││┌ @ stream.jl:283 Base.unlock(%3)
││││││ runtime dispatch detected: Base.unlock(%3::Base.AbstractLock)
│││││└─────────────────
││││┌ @ show.jl:335 Base.unlock(%1)
│││││ runtime dispatch detected: Base.unlock(%1::IO)
││││└───────────────
│││┌ @ strings/io.jl:43 Base.lock(io)
││││ runtime dispatch detected: Base.lock(io::IO)
│││└────────────────────
│││┌ @ strings/io.jl:46 Base.print(io, %6)
││││ runtime dispatch detected: Base.print(io::IO, %6::String)
│││└────────────────────
│││┌ @ strings/io.jl:49 Base.unlock(%32)
││││ runtime dispatch detected: Base.unlock(%32::IO)
│││└────────────────────
││┌ @ strings/io.jl:73 Base.print(io, %1, &quot;\n&quot;)
│││ runtime dispatch detected: Base.print(io::IO, %1::String, &quot;\n&quot;)
││└────────────────────
│┌ @ coreio.jl:4 Base.println(%3, %4)
││ runtime dispatch detected: Base.println(%3::IO, %4::String)
│└───────────────
┌ @ timing.jl:214 Base.time_print(elapsedtime, Base.getproperty(diff, :allocd), Base.getproperty(diff, :total_time), Base.gc_alloc_count(diff), compile_elapsedtime, true)
│┌ @ timing.jl:120 Base.sprint(#850)
││┌ @ strings/io.jl:106 Base.#sprint#416(Core.tuple(Base.nothing, 0, #self#, f), args...)
│││┌ @ strings/io.jl:112 f(Core.tuple(s), args...)
││││┌ @ timing.jl:123 Base.!=(Core.getfield(Core.getfield(#self#, :allocs), :contents), 0)
│││││┌ @ operators.jl:278 Base.==(x, y)
││││││ runtime dispatch detected: Base.==(x::Any, y::Int64)
│││││└────────────────────
│││││┌ @ operators.jl:278 Base.!(%1)
││││││ runtime dispatch detected: Base.!(%1::Any)
│││││└────────────────────
││││┌ @ timing.jl:126 Base.prettyprint_getunits(Core.getfield(Core.getfield(#self#, :allocs), :contents), Base.length(Base._cnt_units), Base.Int64(1000))
│││││┌ @ timing.jl:92 Base.==(value, 0)
││││││ runtime dispatch detected: Base.==(value::Any, 0)
│││││└────────────────
│││││┌ @ timing.jl:92 Base.==(value, 1)
││││││ runtime dispatch detected: Base.==(value::Any, 1)
│││││└────────────────
│││││┌ @ timing.jl:95 Base.log(value)
││││││ runtime dispatch detected: Base.log(value::Any)
│││││└────────────────
│││││┌ @ timing.jl:95 Base./(%7, %9)
││││││ runtime dispatch detected: Base./(%7::Any, %9::Float64)
│││││└────────────────
│││││┌ @ timing.jl:95 Base.ceil(Base.Int, %10)
││││││ runtime dispatch detected: Base.ceil(Base.Int, %10::Any)
│││││└────────────────
│││││┌ @ timing.jl:96 Base.min(numunits, %11)
││││││ runtime dispatch detected: Base.min(numunits::Int64, %11::Any)
│││││└────────────────
│││││┌ @ timing.jl:97 Base.-(%12, 1)
││││││ runtime dispatch detected: Base.-(%12::Any, 1)
│││││└────────────────
│││││┌ @ timing.jl:97 Base.^(factor, %13)
││││││ runtime dispatch detected: Base.^(factor::Int64, %13::Any)
│││││└────────────────
│││││┌ @ timing.jl:97 Base./(value, %14)
││││││ runtime dispatch detected: Base./(value::Any, %14::Any)
│││││└────────────────
││││┌ @ timing.jl:128 Base.print(io, Base.Int(Core.getfield(Core.getfield(#self#, :allocs), :contents)), Base.getindex(Base._cnt_units, ma), _18)
│││││┌ @ strings/io.jl:46 Base.print(io, %5)
││││││ runtime dispatch detected: Base.print(io::IOBuffer, %5::Any)
│││││└────────────────────
││││┌ @ timing.jl:123 Base.!=(%32, 0)
│││││ runtime dispatch detected: Base.!=(%32::Any, 0)
││││└─────────────────
││││┌ @ timing.jl:125 Base.!=(%65, 0)
│││││ runtime dispatch detected: Base.!=(%65::Any, 0)
││││└─────────────────
││││┌ @ timing.jl:126 Base.prettyprint_getunits(%73, %75, 1000)
│││││ runtime dispatch detected: Base.prettyprint_getunits(%73::Any, %75::Int64, 1000)
││││└─────────────────
││││┌ @ timing.jl:127 Base.==(%80, 1)
│││││ runtime dispatch detected: Base.==(%80::Any, 1)
││││└─────────────────
││││┌ @ timing.jl:128 Base.Int(%88)
│││││ runtime dispatch detected: Base.Int(%88::Any)
││││└─────────────────
││││┌ @ timing.jl:128 Base.getindex(Base._cnt_units, %80)
│││││ runtime dispatch detected: Base.getindex(Base._cnt_units, %80::Any)
││││└─────────────────
││││┌ @ timing.jl:128 Base.==(%96, 1)
│││││ runtime dispatch detected: Base.==(%96::Any, 1)
││││└─────────────────
││││┌ @ timing.jl:128 Base.print(io, %89, %90, %101)
│││││ runtime dispatch detected: Base.print(io::IOBuffer, %89::Any, %90::Any, %101::String)
││││└─────────────────
││││┌ @ timing.jl:130 Base.Float64(%110)
│││││ runtime dispatch detected: Base.Float64(%110::Any)
││││└─────────────────
││││┌ @ timing.jl:130 %104(%111, 2)
│││││ runtime dispatch detected: %104::typeof(Base.Ryu.writefixed)(%111::Any, 2)
││││└─────────────────
││││┌ @ timing.jl:130 Base.getindex(Base._cnt_units, %80)
│││││ runtime dispatch detected: Base.getindex(Base._cnt_units, %80::Any)
││││└─────────────────
││││┌ @ timing.jl:130 Base.print(io, %112, %113, &quot; allocations: &quot;)
│││││ runtime dispatch detected: Base.print(io::IOBuffer, %112::String, %113::Any, &quot; allocations: &quot;)
││││└─────────────────
││││┌ @ timing.jl:135 Base.!=(%138, 0)
│││││ runtime dispatch detected: Base.!=(%138::Any, 0)
││││└─────────────────
││││┌ @ timing.jl:141 Base.!=(%172, 0)
│││││ runtime dispatch detected: Base.!=(%172::Any, 0)
││││└─────────────────
│┌ @ timing.jl:148 Base.print(str)
││┌ @ coreio.jl:3 Base.print(%3, %4)
│││ runtime dispatch detected: Base.print(%3::IO, %4::String)
││└───────────────
Tuple{Int64, Float64}

julia&gt; this_module_filter(sv) = sv.mod === @__MODULE__;

julia&gt; @report_dispatch frame_filter=this_module_filter compute(30) # focus on what we wrote, and no error should be reported
No errors !
Tuple{Int64, Float64}</code></pre><p><a href="#JETTest.@test_nodispatch"><code>@test_nodispatch</code></a> can be used to assert that a given function call is free of type instabilities under <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library&#39;s unit-testing infrastructure</a>:</p><pre><code class="language-julia-repl">julia&gt; @test_nodispatch f()
Dispatch Test Failed at none:1
  Expression: #= none:1 =# JETTest.@test_nodispatch f()
  ═════ 6 possible errors found ═════
  ┌ @ none:1 Main.__atexample__named__quickstart.addsincos(Base.getproperty(Main.__atexample__named__quickstart.params, :v1), Base.getproperty(Main.__atexample__named__quickstart.params, :v2))
  │┌ @ none:2 Main.__atexample__named__quickstart.cos(v2)
  ││ runtime dispatch detected: Main.__atexample__named__quickstart.cos(v2::Any)
  │└──────────
  │┌ @ none:2 Main.__atexample__named__quickstart.sin(v1)
  ││ runtime dispatch detected: Main.__atexample__named__quickstart.sin(v1::Any)
  │└──────────
  │┌ @ none:2 Main.__atexample__named__quickstart.+(%1, %2)
  ││ runtime dispatch detected: Main.__atexample__named__quickstart.+(%1::Any, %2::Any)
  │└──────────
  ┌ @ none:1 Base.getproperty(%1, :v1)
  │ runtime dispatch detected: Base.getproperty(%1::Any, :v1::Symbol)
  └──────────
  ┌ @ none:1 Base.getproperty(%3, :v2)
  │ runtime dispatch detected: Base.getproperty(%3::Any, :v2::Symbol)
  └──────────
  ┌ @ none:1 Main.__atexample__named__quickstart.addsincos(%2, %4)
  │ runtime dispatch detected: Main.__atexample__named__quickstart.addsincos(%2::Any, %4::Any)
  └──────────
  
ERROR: There was an error during testing

julia&gt; @test_nodispatch frame_filter=this_module_filter compute(30)
Test Passed
  Expression: #= none:2 =# JETTest.@test_nodispatch frame_filter = this_module_filter compute(30)

julia&gt; using Test

julia&gt; @testset &quot;check type-stabilities&quot; begin
           @test_nodispatch f() # should fail
       
           params = (; v1 = 10, v2 = -10)
           @test_nodispatch f(params) # should pass
       
           @test_nodispatch frame_filter=this_module_filter compute(30) # should pass
       
           @test_nodispatch broken=true compute(30) # should pass with the &quot;broken&quot; annotation
       end
check type-stabilities: Dispatch Test Failed at none:3
  Expression: #= none:3 =# JETTest.@test_nodispatch f()
  ═════ 6 possible errors found ═════
  ┌ @ none:1 Main.__atexample__named__quickstart.addsincos(Base.getproperty(Main.__atexample__named__quickstart.params, :v1), Base.getproperty(Main.__atexample__named__quickstart.params, :v2))
  │┌ @ none:2 Main.__atexample__named__quickstart.cos(v2)
  ││ runtime dispatch detected: Main.__atexample__named__quickstart.cos(v2::Any)
  │└──────────
  │┌ @ none:2 Main.__atexample__named__quickstart.sin(v1)
  ││ runtime dispatch detected: Main.__atexample__named__quickstart.sin(v1::Any)
  │└──────────
  │┌ @ none:2 Main.__atexample__named__quickstart.+(%1, %2)
  ││ runtime dispatch detected: Main.__atexample__named__quickstart.+(%1::Any, %2::Any)
  │└──────────
  ┌ @ none:1 Base.getproperty(%1, :v1)
  │ runtime dispatch detected: Base.getproperty(%1::Any, :v1::Symbol)
  └──────────
  ┌ @ none:1 Base.getproperty(%3, :v2)
  │ runtime dispatch detected: Base.getproperty(%3::Any, :v2::Symbol)
  └──────────
  ┌ @ none:1 Main.__atexample__named__quickstart.addsincos(%2, %4)
  │ runtime dispatch detected: Main.__atexample__named__quickstart.addsincos(%2::Any, %4::Any)
  └──────────
  
Test Summary:          | Pass  Fail  Broken  Total
check type-stabilities |    2     1       1      4
ERROR: Some tests did not pass: 2 passed, 1 failed, 0 errored, 1 broken.</code></pre><h2 id="dispatch-analysis-entry-points"><a class="docs-heading-anchor" href="#dispatch-analysis-entry-points">Entry Points</a><a id="dispatch-analysis-entry-points-1"></a><a class="docs-heading-anchor-permalink" href="#dispatch-analysis-entry-points" title="Permalink"></a></h2><p>These macros/functions are the entries of dispatch analysis:</p><article class="docstring"><header><a class="docstring-binding" id="JETTest.@report_dispatch" href="#JETTest.@report_dispatch"><code>JETTest.@report_dispatch</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@report_dispatch [jetconfigs...] f(args...)</code></pre><p>Evaluates the arguments to the function call, determines its types, and then calls <a href="#JETTest.report_dispatch"><code>report_dispatch</code></a> on the resulting expression. As with <code>@code_typed</code> and its family, any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> or <a href="#dispatch-analysis-configurations">dispatch analysis specific configurations</a> can be given as the optional arguments like this:</p><pre><code class="language-julia"># reports `rand(::Type{Bool})` with `unoptimize_throw_blocks` configuration turned on
julia&gt; @report_call unoptimize_throw_blocks=true rand(Bool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JETTest.jl/blob/7eec633cb4231174ff46d9ab57932676804ef216/src/dispatch.jl#L235-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JETTest.report_dispatch" href="#JETTest.report_dispatch"><code>JETTest.report_dispatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">report_dispatch(f, types = Tuple{}; jetconfigs...) -&gt; result_type::Any</code></pre><p>Analyzes the generic function call with the given type signature, and then prints detected optimization failures and runtime dispatch points to <code>stdout</code>, and finally returns the result type of the call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JETTest.jl/blob/7eec633cb4231174ff46d9ab57932676804ef216/src/dispatch.jl#L205-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JETTest.@analyze_dispatch" href="#JETTest.@analyze_dispatch"><code>JETTest.@analyze_dispatch</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@report_dispatch [jetconfigs...] f(args...)</code></pre><p>Evaluates the arguments to the function call, determines its types, and then calls <a href="#JETTest.analyze_dispatch"><code>analyze_dispatch</code></a> on the resulting expression. As with <code>@code_typed</code> and its family, any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> or <a href="#dispatch-analysis-configurations">dispatch analysis specific configurations</a> can be given as the optional arguments like this:</p><pre><code class="language-julia"># reports `rand(::Type{Bool})` with `unoptimize_throw_blocks` configuration turned on
julia&gt; @analyze_dispatch unoptimize_throw_blocks=true rand(Bool)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JETTest.jl/blob/7eec633cb4231174ff46d9ab57932676804ef216/src/dispatch.jl#L219-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JETTest.analyze_dispatch" href="#JETTest.analyze_dispatch"><code>JETTest.analyze_dispatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">analyze_dispatch(f, types = Tuple{}; jetconfigs...) -&gt; (analyzer::DispatchAnalyzer, frame::Union{InferenceFrame,Nothing})</code></pre><p>Analyzes the generic function call with the given type signature, and returns:</p><ul><li><code>analyzer::DispatchAnalyzer</code>: contains analyzed optimization failures and runtime dispatch points</li><li><code>frame::Union{InferenceFrame,Nothing}</code>: the final state of the abstract interpretation, or <code>nothing</code> if <code>f</code> is a generator and the code generation has been failed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JETTest.jl/blob/7eec633cb4231174ff46d9ab57932676804ef216/src/dispatch.jl#L190-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JETTest.@test_nodispatch" href="#JETTest.@test_nodispatch"><code>JETTest.@test_nodispatch</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@test_nodispatch [jetconfigs...] [broken=false] [skip=false] f(args...)</code></pre><p>Tests the generic function call <code>f(args...)</code> is free from runtime dispatch. Returns a <code>Pass</code> result if it is, a <code>Fail</code> result if if contains any location where runtime dispatch or optimization failure happens, or an <code>Error</code> result if this macro encounters an unexpected error. When the test <code>Fail</code>s, abstract call stack to each problem location will also be printed to <code>stdout</code>.</p><pre><code class="language-julia">julia&gt; @test_nodispatch sincos(10)
Test Passed
  Expression: #= none:1 =# JETTest.@test_nodispatch sincos(10)</code></pre><p>As with <a href="#JETTest.@report_dispatch"><code>@report_dispatch</code></a> or <a href="#JETTest.@analyze_dispatch"><code>@analyze_dispatch</code></a>, any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> or <a href="#dispatch-analysis-configurations">dispatch analysis specific configurations</a> can be given as the optional arguments like this:</p><pre><code class="language-julia">julia&gt; function f(n)
            r = sincos(n)
            println(r) # `println` is full of runtime dispatches, but we can ignore the corresponding reports from `Base` by explicit frame filter
            return r
       end;
julia&gt; this_module_filter(x) = x.mod === @__MODULE__;

julia&gt; @test_nodispatch frame_filter=this_module_filter f(10)
Test Passed
  Expression: #= none:1 =# JETTest.@test_nodispatch frame_filter = this_module_filter f(10)</code></pre><p><code>@test_nodispatch</code> is fully integrated with <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code> standard library&#39;s unit-testing infrastructure</a>. It means, the result of <code>@test_nodispatch</code> will be included in the final <code>@testset</code> summary, it supports <code>skip</code> and <code>broken</code> annotations as <code>@test</code> macro does, etc.</p><pre><code class="language-julia">julia&gt; using JETTest, Test

julia&gt; f(params) = sin(params.value); # type-stable
julia&gt; params = (; value = 10);       # non-constant global variable
julia&gt; g() = sin(params.value);       # very type-instable

julia&gt; @testset &quot;check optimizations&quot; begin
           @test_nodispatch f((; value = 10)) # pass
           @test_nodispatch g()               # fail
           @test_nodispatch broken=true g()   # annotated as broken, thus still &quot;pass&quot;
       end
check optimizations: Dispatch Test Failed at none:3
  Expression: #= none:3 =# JETTest.@test_nodispatch g()
  ═════ 2 possible errors found ═════
  ┌ @ none:1 Base.getproperty(%1, :value)
  │ runtime dispatch detected: Base.getproperty(%1::Any, :value::Symbol)
  └──────────
  ┌ @ none:1 Main.sin(%2)
  │ runtime dispatch detected: Main.sin(%2::Any)
  └──────────

Test Summary:       | Pass  Fail  Broken  Total
check optimizations |    1     1       1      3
ERROR: Some tests did not pass: 1 passed, 1 failed, 0 errored, 1 broken.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JETTest.jl/blob/7eec633cb4231174ff46d9ab57932676804ef216/src/dispatch.jl#L254-L313">source</a></section></article><h2 id="dispatch-analysis-configurations"><a class="docs-heading-anchor" href="#dispatch-analysis-configurations">Configurations</a><a id="dispatch-analysis-configurations-1"></a><a class="docs-heading-anchor-permalink" href="#dispatch-analysis-configurations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="JETTest.DispatchAnalyzer" href="#JETTest.DispatchAnalyzer"><code>JETTest.DispatchAnalyzer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Every <a href="#dispatch-analysis-entry-points">entry point of dispatch analysis</a> can accept any of <a href="https://aviatesk.github.io/JET.jl/dev/config/">JET configurations</a> as well as the following additional configurations that are specific to dispatch analysis:</p><ul><li><p><code>frame_filter = x::Union{Core.Compiler.InferenceState, Core.Compiler.OptimizationState}-&gt;true</code>:<br/>A predicate which takes <code>InfernceState</code> or <code>OptimizationState</code> and returns <code>false</code> to skip analysis on the frame.</p></li><li><p><code>function_filter = @nospecialize(ft)-&gt;true</code>:<br/>A predicate which takes a function type and returns <code>false</code> to skip analysis on the call.</p></li><li><p><code>analyze_unoptimized_throw_blocks::Bool = false</code>:<br/>By default, Julia&#39;s native compilation pipeline intentionally disables inference (and so succeeding optimizations too) on &quot;throw blocks&quot;, which are code blocks that will eventually lead to <code>throw</code> calls, in order to ease <a href="https://julialang.org/blog/2020/08/invalidations/">the compilation latency problem, a.k.a. &quot;first-time-to-plot&quot;</a>. Accordingly, the dispatch analyzer also ignores runtime dispatches detected within those blocks since we <em>usually</em> don&#39;t mind if code involved with error handling isn&#39;t optimized. If <code>analyze_unoptimized_throw_blocks</code> is set to <code>true</code>, it doesn&#39;t ignore them and will report type instabilities detected within &quot;throw blocks&quot;.</p><p>See also <a href="https://github.com/JuliaLang/julia/pull/35982">https://github.com/JuliaLang/julia/pull/35982</a>.</p></li></ul><p><strong>Configuration Examples</strong></p><pre><code class="language-julia"># only checks code within the current module:
julia&gt; mymodule_filter(x) = x.mod === @__MODULE__;
julia&gt; @report_dispatch frame_filter=mymodule_filter f(args...)
...

# ignores `Core.Compiler.widenconst` calls (since it&#39;s designed to be runtime-dispatched):
julia&gt; myfunction_filter(@nospecialize(ft)) = ft !== typeof(Core.Compiler.widenconst)
julia&gt; @report_dispatch function_filter=myfunction_filter f(args...)
...

# by default, unoptimized &quot;throw blocks&quot; are not analyzed
julia&gt; @test_nodispatch sin(10)
Test Passed
  Expression: #= none:1 =# JETTest.@test_nodispatch sin(10)

# we can turn on the analysis on unoptimized &quot;throw blocks&quot; with `analyze_unoptimized_throw_blocks=true`
julia&gt; @test_nodispatch analyze_unoptimized_throw_blocks=true sin(10)
Dispatch Test Failed at none:1
  Expression: #= none:1 =# JETTest.@test_nodispatch analyze_unoptimized_throw_blocks = true sin(10)
  ═════ 1 possible error found ═════
  ┌ @ math.jl:1221 Base.Math.sin(xf)
  │┌ @ special/trig.jl:39 Base.Math.sin_domain_error(x)
  ││┌ @ special/trig.jl:28 Base.Math.DomainError(x, &quot;sin(x) is only defined for finite x.&quot;)
  │││ runtime dispatch detected: Base.Math.DomainError(x::Float64, &quot;sin(x) is only defined for finite x.&quot;)
  ││└──────────────────────

ERROR: There was an error during testing

# we can also turns off the heuristic itself
julia&gt; @test_nodispatch unoptimize_throw_blocks=false analyze_unoptimized_throw_blocks=true sin(10)
Test Passed
  Expression: #= none:1 =# JETTest.@test_nodispatch unoptimize_throw_blocks = false analyze_unoptimized_throw_blocks = true sin(10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/aviatesk/JETTest.jl/blob/7eec633cb4231174ff46d9ab57932676804ef216/src/dispatch.jl#L4-L58">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../generated-index/">« README</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 17 June 2021 07:07">Thursday 17 June 2021</span>. Using Julia version 1.8.0-DEV.42.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
